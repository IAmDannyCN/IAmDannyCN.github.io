<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Measurement | IAD's Blog</title><meta name="author" content="I_Am_Danny"><meta name="copyright" content="I_Am_Danny"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="简介这里是一个对于经典网络测量工作的总结，目前包括： 主动测量：  Pingmesh(Microsoft, SIGCOMM’15) R-Pingmesh(ByteDance, SIGCOMM’24) RD-Probe(HuaWei, SIGCOMM’24)  被动测量：  PINT(SIGCOMM’20) DART(SIGCOMM’22) Passive Realtime Datacenter F">
<meta property="og:type" content="article">
<meta property="og:title" content="Measurement">
<meta property="og:url" content="http://blog.iamdanny.online/2025/11/14/%E7%BD%91%E7%BB%9C/Measurement/index.html">
<meta property="og:site_name" content="IAD&#39;s Blog">
<meta property="og:description" content="简介这里是一个对于经典网络测量工作的总结，目前包括： 主动测量：  Pingmesh(Microsoft, SIGCOMM’15) R-Pingmesh(ByteDance, SIGCOMM’24) RD-Probe(HuaWei, SIGCOMM’24)  被动测量：  PINT(SIGCOMM’20) DART(SIGCOMM’22) Passive Realtime Datacenter F">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://blog.iamdanny.online/img/icon.JPG">
<meta property="article:published_time" content="2025-11-14T07:00:00.000Z">
<meta property="article:modified_time" content="2025-11-17T13:39:32.215Z">
<meta property="article:author" content="I_Am_Danny">
<meta property="article:tag" content="网络">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://blog.iamdanny.online/img/icon.JPG"><link rel="shortcut icon" href="/img/icon.JPG"><link rel="canonical" href="http://blog.iamdanny.online/2025/11/14/%E7%BD%91%E7%BB%9C/Measurement/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Measurement',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-11-17 21:39:32'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/icon.JPG" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/banner.png')"><nav id="nav"><span id="blog-info"><a href="/" title="IAD's Blog"><span class="site-name">IAD's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Measurement</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-11-14T07:00:00.000Z" title="发表于 2025-11-14 15:00:00">2025-11-14</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-17T13:39:32.215Z" title="更新于 2025-11-17 21:39:32">2025-11-17</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Measurement"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这里是一个对于经典网络测量工作的总结，目前包括：</p>
<p><strong>主动测量</strong>：</p>
<ul>
<li>Pingmesh(Microsoft, SIGCOMM’15)</li>
<li>R-Pingmesh(ByteDance, SIGCOMM’24)</li>
<li>RD-Probe(HuaWei, SIGCOMM’24)</li>
</ul>
<p><strong>被动测量</strong>：</p>
<ul>
<li>PINT(SIGCOMM’20)</li>
<li>DART(SIGCOMM’22)</li>
<li>Passive Realtime Datacenter Fault Detection and Localization(Facebook, NSDI’17)</li>
<li>Everflow(SIGCOMM’15)</li>
<li>ChameleMon(SIGCOMM’23)</li>
<li>FlowRadar(NSDI’16)</li>
<li>LossRadar(CoNext’16)</li>
</ul>
<p>网络测量的目的是以一定粒度对整个网络的性能表现进行分析，其中性能表现包括但不限于：时延、丢包率、抖动等。</p>
<p>从测量方式上分类，分为主动测量和被动测量两种：主动测量一般会由服务端主动发起 Ping 请求（或修改过的基于 TCP 的 Ping 等）主动探测网络性能，被动测量通过部署流量监控套件收集信息进行在线或离线的分析。由于广域网结构复杂，且 ISP 内事件和架构对厂商不可见，因此主动拨测常用于内网的故障检测；在 ISP 对接的 POP 点部署被动测量监控广域网往往是一个更好的方案。并且，被动测量不用向网络中注入额外流量，更容易做到细粒度的测量，便于故障定界。</p>
<h2 id="Pingmesh"><a href="#Pingmesh" class="headerlink" title="Pingmesh"></a>Pingmesh</h2><p>Pingmesh 由微软提出，已经在微软 DCN 内大规模部署（AliPing 也使用了该方案）。Pingmesh 使主机主动发起并回复 Ping 请求，通过监测 Ping 请求的完成时间对 DCN 间链路进行测量。同时，Pingmesh 能够作为一个背景服务保持长期上线，因此能够无间断地，甚至在服务上线之前收集并分析网络数据。</p>
<p>Pingmesh 将 DCN 的拓扑抽象为三个层级：主机、机架、机房；Pingmesh 希望能够做到链路的 100% 检测覆盖率（主机间完全图覆盖），即：任意两个主机之间的链路都至少被检测一次。但考虑到 DCN 拓扑，同一个机架内的两台机器对外发送请求时，会使用同一个 ToR 交换机；同一个机房内的两台机器对外发送请求时，也会使用同一个机房交换机；这些节点资源是向下复用的，因此没有必要实现任意两主机之间的完全图覆盖，而仅需要保证：机架内主机的完全图覆盖、机房内机架的完全图覆盖、机房间机房的完全图覆盖即可。机器具体的 Ping 列表生成根据各个机房结构不同，算法差异较大。<br><img src="/2025/11/14/%E7%BD%91%E7%BB%9C/Measurement/image-20251113203245355.png"><br>由于 Pingmesh 是端侧的主动拨测方案，每一台 DCN 内的主机都需要部署 Pingmesh 服务。因此 Pingmesh 在实现时需要非常注意跨平台的兼容性和高效率。此外，出于与被检测协议栈解耦的需要，Pingmesh 额外编写了一套轻量级的网络栈，以免在被检测协议栈大规模故障时受到波及。在部署上，Pingmesh 将节点分为：Controller（中心化服务器，负责下发 Ping 表项）、Agent（每一台机器，接收表项并定时 Ping，将数据上传到 DSA）、DSA（中心化服务器，收集 Ping 数据并分析）。<br><img src="/2025/11/14/%E7%BD%91%E7%BB%9C/Measurement/image-20251113203153439.png"><br>在收集并分析数据时，Pingmesh 主要收集 Ping 的 RTT，该值包括了网络相关的时延（排队时延、传输时延、处理时延）和网络无关的时延（协议栈时延、DMA 数据传输时延等）。Pingmesh 利用了 TCP 流量重传时的指数回退机制，从 SYN 包的传输间隔反推是否产生丢包，从而计算丢包率：<br>$$DropRate&#x3D;\frac{ProbesWith3sRTT+ProbsWith9sRTT}{TotalSuccessfulProbes}$$</p>
<h2 id="R-Pingmesh"><a href="#R-Pingmesh" class="headerlink" title="R-Pingmesh"></a>R-Pingmesh</h2><p>R-Pingmesh 是将 Pingmesh 扩展到 RoCE 网络中的尝试。出于以下原因，传统的 Pingmesh 并不能直接适用于 RoCE 网络：</p>
<ul>
<li>TCP-Pingmesh 不能检测 RoCE 特有的问题（如 PFC）</li>
<li>TCP 与 RoCE 流量在 RNIC 中会被分为两条独立路径处理</li>
<li>Pingmesh 只能以端到端的粒度进行检测，无法区分链路上的具体故障（交换机故障&#x2F;RNIC故障）</li>
<li>Pingmesh 将所有时延汇总测量，无法区分网络时延和系统时延</li>
<li>Pingmesh 只能提供最低限度的连通性测试，无法为故障定级</li>
</ul>
<p>R-Pingmesh 的架构设计与 Pingmesh 大体相似；但由于 RoCE 不存在跨机房流量，因此只需要检测机架内和机架间的流量即可（R-Pingmesh 将该模块称为 Cluster Monitoring）。在此之外，R-Pingmesh 通过针对实际 RMDA 连接的五元组构造 Ping 请求的方式，为实际的流提供了 SLA 的实时监测（该模块称为 Service Tracing）。<br><img src="/2025/11/14/%E7%BD%91%E7%BB%9C/Measurement/image-20251114151824791.png"></p>
<p>Controller 维护所有 RNIC 的 GID 和 DPN 以分配 Ping 任务，在 RNIC 重启时会主动上报更新。在计算 Pinglist 时，R-Pingmesh 并不保证所有链路都能完全覆盖，而是以 99% 全覆盖的概率随机分配 Ping 任务并下发 Pinglist。Controller 还会负责在 Service Tracing 环节中提供 RNIC 信息。</p>
<p>Actor 使用 RMDA 包封装了一个 Ping。RDMA QP 分为三种：RC、UC、UD；分别可类比为：TCP、带连接的UDP、UDP。由于目标是收集 RTT，因此我们希望在发包和收包时都产生一个时间戳；然而 RC 默认只会在 ACK 之后产生一个有时间戳的 CQE，因此 R-Pingmesh 不考虑使用 RC。又因为 RC 和 UC 都是带连接的，使用时会占用一定 QPC 资源。因此 Actor 考虑利用 UD QP 进行通讯。在具体实现上，使用 eBPF 跟踪 qp 的创建和销毁即可。</p>
<p>Analyzer 的实现较为朴素。在得到异常数据（超时、高 RTT）后，Analyzer 首先排除所有非网络问题（如：机器故障下线、RNIC 重启导致的 QPN Reset 等），这些问题多半是由于 Controller 信息更新不及时导致的，再次使用新版 Controller 信息同步即可排查。对于网络问题，R-Pingmesh 直接按异常路径逐条打标记，标记次数最多的设备判定为异常设备。使用该方案可以实现故障定界和故障定级。</p>
<p>当使用以上的 Cluster Monitoring 得到异常数据后，还可以使用 Service Tracing 进一步追踪，以排除 GPU 死锁、CPU 负载均衡等非网络问题。</p>
<h2 id="RD-Probe"><a href="#RD-Probe" class="headerlink" title="RD-Probe"></a>RD-Probe</h2><p>TODO</p>
<h2 id="PINT"><a href="#PINT" class="headerlink" title="PINT"></a>PINT</h2><p>PINT 是基于 INT（In-band Network Telemetry）的。INT 的思路是：让 Switch 在数据包中插入数据，让接收端获得数据包传输过程中的测量信息。但这个做法在跳数较多时会严重浪费带宽。假设 INT 占用总带宽的比例从 $3%$ 上升到 $7%$，在原 Goodput 为 $70%$ 的情况下，INT 的变化将会使剩余容量下降到原来的 $1-\frac{1-0.7\times 1.07}{1-0.7\times 1.03}&#x3D;0.47$ 倍。PINT 将 Switch 收集的数据分布在不同的数据包里，在接收端做聚合来还原完整数据，将额外开销限制在了一个固定值。</p>
<p>用户在一个 PINT 请求中，除了指定 value 和 aggregate function 以外，还可以指定 bit-budget 和 space-budget，分别代表每个包额外使用的最大空间，和客户端为处理每个流而 alloc 的最大空间。PINT 采用随机化的方式，将数据收集的任务概率性地指派给各 Switch，而后在接收端完成聚合。</p>
<p>在指派任务时，PINT 主要采用了三个方案：全局哈希、分布式编码、数据压缩。</p>
<ul>
<li>全局哈希：PINT 让所有 Switch 和终端采用相同的哈希函数和伪随机数生成器。通过这种方法，无需一个中心化的服务器或分布式的协商就能完成任务指派和切分。Switch 直接对 $(packetID,hopNumber)$ 做哈希来判断自己是否需要操作该数据包。终端也能通过同样的哈希函数判断一个包被哪些 Switch 操作过。</li>
<li>分布式编码：PINT 采用概率性的编码实现分布式编码。例如让所有 Switch 都以蓄水池采样的方式将包中数据修改为自身数据，则对于一个跳数为 $k$ 的流，需要 $O(k\log k)$ 个包收集到所有 Switch 的数据。除此之外，也可以让每个 Switch 以概率 $p$ 将自身数据异或到包上，在终端实现解码。</li>
<li>数据压缩：我们可以对数据进行进一步压缩，例如除以 $D$ 存储（乘性误差）或对 $L$ 取 $\log$ 存储（加性误差）。这是一种变相的哈希，在传输某些稀疏值（例如 Switch ID）时可以使用。除此之外，在探测拥塞等不需要高精度统计的场景也可以酌情使用。<br><img src="/2025/11/14/%E7%BD%91%E7%BB%9C/Measurement/image-20251117195904550.png"></li>
</ul>
<p>在聚合时，PINT 支持三种聚合方法：Per-Packet、Static Per-FLow、Dynamic Per-Flow。</p>
<ul>
<li>Per-Packet：让 Switch 直接运行聚合函数，在包传递的过程中完成聚合。适用于包粒度的检测，如拥塞探测。</li>
<li>Static Per-Flow：让 Switch 用分布式编码保存数据，终端进行聚合。适用于流粒度的检测，如路径追踪。</li>
<li>Dynamic Per-Flow：让 Switch 在运行聚合函数的同时，用分布式编码保存数据，终端进行解码和聚合。适用于同流不同包可能有差别的检测，如逐跳延迟查询。</li>
</ul>
<h2 id="DART"><a href="#DART" class="headerlink" title="DART"></a>DART</h2><p>TODO</p>
<h2 id="Facebook"><a href="#Facebook" class="headerlink" title="Facebook"></a>Facebook</h2><p>Facebook 基于他们的机房架构，设计了一套故障定位系统。他们没有直接侵入监控机房里的设备，而是从四层 TCP 的表现反推机房故障。<br><img src="/2025/11/14/%E7%BD%91%E7%BB%9C/Measurement/image-20251117175520527.png"><br>最下面灰色的是 ToR，每 48 个 ToR 构成一个 Pod。一个 Pod 内有 4 个 Agg Switch，每个 Agg 向下与每个 ToR 连接，向上与 Plane 内 Core Switch 连接。在同一个 Pod 内的两个 Agg 由于不属于同一个 Plane，因此不会连到同一个 Core。所以只要定位走了哪个 Core（和主机 ID），就能还原出整条链路。</p>
<p>基于此，Facebook 直接利用了三层协议 header 里的 IPv6 DSCP 字段标记 Core。事实上也可以使用其他字段，例如 TTL，但 Facebook 现网交换机暂时不支持。文章也提到了一种应对更通用的机房架构的方案：假设链路上有 $D$ 跳，每跳有 $C$ 种选择，我们从头到尾一层一层去遍历所有可能的交换机，如果某次遍历中了，那个交换机就把数据包里某个标志位置 $1$。<strong>相当于暴力把所有可能的机器全询问了一遍</strong>。这样在 $D\times C$ 个数据包以内，以 1 个 bit 为代价可以查询出链路。当然这里一定会需要一些方法标记当前查询的是哪个交换机，但论文里没算进空间开销，如果按 TCP 做也能直接用包编号代表查询编号，但需要交换机能根据查询编号 map 出查的是不是自己。</p>
<p>而后，使用这套系统检测带路径的 cwnd&#x2F;ssthresh&#x2F;srtt&#x2F;retransmission&#x2F;syscall-latency 数据，先根据路径进行分组聚合，得到每条路径对应的数据。然后再根据待分析的链路区间聚合，得到流经某个链路（如某个 Agg 到某个 Core）的所有流的数据的聚合。这些数据可以横向对比来分析某个具体的链路区间有没有出问题。Facebook 使用 T 检验来判断某个值是否是异常的（即判断「某个链路的对应值是异常的」这个假设的成立概率）。但这样会因为抖动产生假阳（本质是划分的粒度太细）；Facebook 假设抖动的出现是均匀的，因此假阳的出现也是均匀的，所以 Controller 会聚合一段时间内的异常上报，再通过假设检验判断是否真的有异常。</p>
<h2 id="Everflow"><a href="#Everflow" class="headerlink" title="Everflow"></a>Everflow</h2><p>TODO</p>
<h2 id="ChameleMon"><a href="#ChameleMon" class="headerlink" title="ChameleMon"></a>ChameleMon</h2><p>ChameleMon 想解决的问题是：在有限的计算和存储资源下，既要支持 packet accumulation task（流量统计、大象流筛选等，主要使用各种 Sketch 来做），又要支持 packet loss tasks（丢包检测，主要使用 IBLT 和各种可编程交换机特性来做），还不想像 FlowRadar 那样维护所有流信息。为此，ChameleMon 将所有流分为三类：HH（Heavy-Hitter）、HL（Heavy-Loss）、LL（Light-Loss）。</p>
<p>ChameleMon 在 Ingress 处用一个 TowerSketch 做流分类（HH&#x2F;HL&#x2F;LL）；在网络入口布置 HH&#x2F;HL&#x2F;LL 三个 FermatSketch，在网络出口布置 HL&#x2F;LL 两个 FermatSketch。HH 的结果直接可用于 packet accumulation task；两组 HL&#x2F;LL 之差可用于 packet loss tasks。控制面可以根据任务精度需要，实时地调整这几个 FermatSketch 占用的空间。由于 FermatSketch 支持直接横向加表以提高精度，所以不需要额外的维护操作。<br><img src="/2025/11/14/%E7%BD%91%E7%BB%9C/Measurement/image-20251117205139606.png"><br><strong>对于 packet loss tasks，需要注意出入口之间存在 inflight 的包</strong>。因此可以让入口给所有流入的包打一个 0&#x2F;1 的标记（逻辑时钟），隔一段（相对于 rtt 较长的）时间翻转。同时，所有 Sketch 维护两份，对应逻辑时钟为 0&#x2F;1 的数据。控制面在逻辑时钟翻转后等待一段时间（至少超过 stt）拉取 sketch 进行分析。</p>
<h2 id="FlowRadar"><a href="#FlowRadar" class="headerlink" title="FlowRadar"></a>FlowRadar</h2><p>TODO</p>
<h2 id="LossRadar"><a href="#LossRadar" class="headerlink" title="LossRadar"></a>LossRadar</h2><p>TODO</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="http://blog.iamdanny.online">I_Am_Danny</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="http://blog.iamdanny.online/2025/11/14/%E7%BD%91%E7%BB%9C/Measurement/">http://blog.iamdanny.online/2025/11/14/%E7%BD%91%E7%BB%9C/Measurement/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://blog.iamdanny.online" target="_blank">IAD's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%BD%91%E7%BB%9C/">网络</a></div><div class="post_share"><div class="social-share" data-image="/img/icon.JPG" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2025/11/03/%E7%BD%91%E7%BB%9C/Filters%20and%20Sketches/" title="Filters &amp; Sketches"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Filters &amp; Sketches</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/11/03/%E7%BD%91%E7%BB%9C/Filters%20and%20Sketches/" title="Filters &amp; Sketches"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-11-03</div><div class="title">Filters &amp; Sketches</div></div></a></div><div><a href="/2025/09/25/%E7%BD%91%E7%BB%9C/ai4sys_CC/" title="网络组实习感想（AI4Sys_端到端拥塞控制）"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-25</div><div class="title">网络组实习感想（AI4Sys_端到端拥塞控制）</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/icon.JPG" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">I_Am_Danny</div><div class="author-info__description">I_Am_Not_Danny</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">41</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">4</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/IAmDannyCN"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/IAmDannyCN" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pingmesh"><span class="toc-number">2.</span> <span class="toc-text">Pingmesh</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#R-Pingmesh"><span class="toc-number">3.</span> <span class="toc-text">R-Pingmesh</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RD-Probe"><span class="toc-number">4.</span> <span class="toc-text">RD-Probe</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PINT"><span class="toc-number">5.</span> <span class="toc-text">PINT</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DART"><span class="toc-number">6.</span> <span class="toc-text">DART</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Facebook"><span class="toc-number">7.</span> <span class="toc-text">Facebook</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Everflow"><span class="toc-number">8.</span> <span class="toc-text">Everflow</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ChameleMon"><span class="toc-number">9.</span> <span class="toc-text">ChameleMon</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#FlowRadar"><span class="toc-number">10.</span> <span class="toc-text">FlowRadar</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LossRadar"><span class="toc-number">11.</span> <span class="toc-text">LossRadar</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2024 - 2025 By I_Am_Danny</div><div class="footer_custom_text"><style>.custom-link { font-family: "微软雅黑 Bold"; font-size: 16px; color: #0016BA; text-decoration: none; transition: color 0.5s, opacity 0.5s; } .custom-link:hover { color: #C40003; text-decoration: none; } .custom-link:visited { color: #0016BA; } </style><script>function changeTextOnHover(element, newText, originalText) { element.onmouseover = function() { element.style.opacity = 0; setTimeout(function() { element.innerText = newText; element.style.opacity = 1; }, 500); }; element.onmouseout = function() { element.style.opacity = 0; setTimeout(function() { element.innerText = originalText; element.style.opacity = 1; }, 500); }; } window.onload = function() { var linkElement = document.getElementById("custom-link"); changeTextOnHover(linkElement, "如潮涌至 领你归乡", "愿为逝者哀哭 泣下如雨 充盈渡川"); };</script><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Ri421X7sS" id="custom-link" class="custom-link">愿为逝者哀哭 泣下如雨 充盈渡川</a><br></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.min.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>